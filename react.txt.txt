=== react ===

React -> Biblioteca javascript criada pelo Facebook que permite criar interfaces web de forma mais rápida, reativa e modular.
jsx   -> extensão com html e código javascript.
tsx   -> extensão com html e código typescript.
Babel -> transpilador que converte o código jsx/tsx e typescript em código compatível com navegador. 

OBS: O babel interpreta jsx/tsx dentro de arquivos js/ts (typescript) sem especificar a extensão jsx/tsx.


Elementos de um app

Componente -> bloco de código html que pode ser reutilizado e gerenciado como um elemento individual. 
	      OBS: Em react, a hierarquia dos componentes seguem o formato XML. Todos os componentes
		   precisam ser fechados inclusive as tags HTML sem fechamento. Ex: <br/>, <input/>, <Componente/>.

Prop 	   -> parâmetros de dados que um componente usa para renderizar conteúdo dinamicamente.
Hook	   -> funções especiais que facilitam o gerenciamento de estados e ciclo de vida de componentes do app.


Estrutura de um app

node_modules -> diretório com as dependências e módulos do projeto instalados com npm. OBS: Só pode ser geranciado via npm.
public	     -> diretório com os arquivos externos que o app usa, como imagens, ícones, fontes e o index.html.
src	     -> diretório com os arquivos principais do projeto, como estilos, componentes, utilitários, App.js e index.js.

App.js     		-> componente principal que reúne todos os componente da interface e o arquivo onde o projeto é desenvolvido.
app.css			-> estilos locais para os componentes do app. É importado no arquivo App.js.
root 	   		-> div presente no index.html com id root onde o react irá renderizar o conteúdo do app.
index.html 		-> arquivo html que serve de base para renderização de conteúdo. OBS: O app não pode ser aberto diretamente no index.html.
index.js   		-> script que renderiza o componente app no root.
index.css		-> estilos para configurações gerais do app como largura do body e html. É importado no index.js. 
package.json		-> contém metadados do app como nome do app, autor, versão do app, licença, scripts e dependências.
package-lock.json	-> trava a estrutura dos pacotes, versões de dependência específicas do projeto para garantir estabilidade e padronização.
readme.md		-> arquivo markdown com a documentação do projeto, apresentando e especificando restrições de instalação, modificação e uso.

Executando o script do app no terminal powershell do vscode

1 - abrir o poweshell do windows como administrador
2 - inserir comando Set-executionPolicy RemoteSigned para permitir execução de scripts locais no powershell
3 - digitar "s" para confirmar

OBS: Para reverter basta inserir Set-executionPolicy Restricted


Gerenciando o projeto react via terminal powershell

mkdir <diretorio do projeto> 	-> cria p diretório do projeto
cd <diretorio do projeto>	-> move para o diretório do projeto
npx create-react-app app 	-> cria um app react chamado "app" dentro do diretório
npm start 			-> executa o app abrindo um servidor local e uma aba no navegador. Executa o script "start" no package.json
npm install <pacote>		-> instala uma nova dependência do projeto em node_modules.


Criando componentes

Obrigatório: O componente deve ser exportado como default num arquivo js/jsx individual. 
Boa prática: O componente deve ter o mesmo nome do arquivo.

componente funcional (mais usado)

	import React from 'react';

	function ComponenteFuncional(){
     		return <p>Componente funcional</p>;
	}
	export default ComponenteFuncional;

componente de classe

	import React, {Component} from 'react';

	class ComponenteClasse extends Component{
		render(){
			return <p>Componente de classe</p>;
		}
	}
	export default ComponenteClasse;

Componentes de classe extendem a classe Componente para herder os métodos para
criar componentes e gerenciar estado seu e ciclo de vida. Características:

    Usam uma sintaxe mais antiga de componentes React e não suportam hooks modernos.

    Os states e props são inicializados no construtor do componente.

    super(props) -> chama o método construtor da classe Component para incializar as props.

    Props, estadoos e métodos do componente são acessados usando this. Ex: this.metodo(), this.state.estado e this.props.prop

    O state é pasado como um objeto {key: value, ...} em this.state e atualizado pela função setState({key: value, ...});

    OBS: Tecnicamente é possível atualizar o valor do state diretamente pela propriedade state.propriedade, mas isso gerará comportamentos inesperados no componente e não será renderizado ao mudar o valor.

    O ciclo de vida não é gerenciado por hooks, e sim sobrescrevendo os métodos de Component que executam uma
    operação em determinadas situações:

    render() -> retorna o jsx do componente.
    componentDidMount() -> executado quando o componente é inserido no virtual DOM. Equivalente ao useEffect(()=> ..., [])
    componentDidUpdate() -> executado quando o estado é atualizado. Equivalente ao useEffect(()=> ...)
    componentWillUnmound() -> executado quando o componente estiver prestes a ser removido do virtual DOM.


Composição de componentes funcionais

	function App(){
		return(
		    <>
		       <Cabecalho/>
		       <Main/>
		       <Rodape/>
		    </>
		);
	}
	export default App;

OBS: Todo componente só pode retornar um componente ou elemento html. Usa-se <></> para retornar mais de um no componente. 

Propriedades de componentes (props) -> são passadas como um objeto com dados chave e valor

	function Pessoa(props){
    		return (
        	    <article>
            	      	 <p>Nome: {props.nome}</p>
            	         <p>Idade: {props.idade}</p>
            	         <p>Condição: {props.idade >= 18? 'Maior de idade': 'Menor de idade'}</p>
			 <br/>
        	    </article>
    		);
	}
	export default Pessoa;

Declarando props usando desestruturação de objeto:

	function Pessoa({nome, idade}){
    		return (
        	    <article>
            	      	 <p>Nome: {nome}</p>
            	         <p>Idade: {idade}</p>
            	         <p>Condição: {idade >= 18? 'Maior de idade': 'Menor de idade'}</p>
			 <br/>
        	    </article>
    		);
	}
	export default Pessoa;

OBS: O código js com variáveis e funções é inserido no jsx dentro de chaves.


Contenção de componentes -> permite inserir componentes ou html dentro de outro
   			    componente envolvendo-os entre sua abertura e fechamento. 
  			    Os filhos evolvidos são inseridos e organizados no pai por meio da propriedade 
  			    props.children, que é a lista de componentes filhos. Ex:
No ComponentePai.js:

	export default function ComponentePai(props){
        	return <div>{props.children}</div>; // insere todos os filhos na ordem do jsx  	
   	}


No App.js:

import ComponentePai from "./componentes/ComponentePai";
import Filho1 from "./componentes/Filho1";
import Filho2 from "./componentes/Filho2";
import Filho3 from "./componentes/Filho3";

	export default function App(){
   		<ComponentePai>
        		<Filho1/>
        		<Filho2/>
        		<Filho3/>
   		</ComponentePai>
	}


props.children[0] -> insere o primeiro filho da ordem do jsx
props.children[props.children.length-1] -> insere o último filho da ordem do jsx


Ciclo de vida dos componentes

Montagem (Mounting)        -> Quando o componente é renderizado pela primeira vez no virtual DOM.
Atualização (Update)       -> Quando algum estado é atualizado e o componente é re-renderizado.
Desmontagem (Unmounting)   -> Quando o compontes é removido do virtual DOM dinamicamente.

Tratamento de erro/error bundary (opcional) -> Error boundary usa um componente que captura e trata erros de componentes filhos
e sobrescreve os métodos getDeviredStateFromError e componentDidCatch.

Em componentes funcionais, o react usa hooks como useEffect para gerenciar o ciclo de vida.

Em componentes de classe, o react usa um conjunto de métodos:

Mounting:

1º constructor()                      -> instancia o componente e recebe as props como parâmetros
2º static getDerivedStateFromProps()  -> sincroniza os estados passados via props
3º render()                           -> retorna o jsx renderizado pela aplicação
4º componentDidMount()                -> executa uma operação depois de ser renderizado 

Update:

1º static getDerivedStateFromProps()   -> sincroniza os estados passados via props
2º shouldComponentUpdate()             -> testa a condição de renderização
3º render()                            -> renderiza novamente
4º getSnapshotBeforeUpdate()           -> retorna os estados e props anteriores para o componentDidUpdate 
5º componentDidUpdate()                -> executa uma operação depois de atualizado

Unmounting:

1º componentWillUnmount()  -> executa uma operação antes de ser desmontado.


Error boundary:

1º static getDeviredStateFromError()    -> atualiza o estado que gerencia o tratamento do erro
2º componentDidCatch(error, erroInfo)   -> executa o tratamento do erro


Desestruturação de objeto:

	const pessoa = {nome:"Maria", idade: 30};
	const {nome, idade} = pessoa; // declara as constantes nome e idade a partir da desestruturação do objeto.
	console.log(nome + " " + idade); // Maria 30

Desestruturação de array:

	const nums = [10, 20, 30, 40];
	const [n1, n2, n3, n4] = nums; // declara 4 constantes numéricas a partir da desestruturação do array.
	console.log(n1 + n2 + n3 + n4); // 100


Importação e exportação 

export 		 -> exporta um recurso (componente, função, classe ou variável) para ser usado em outro arquivo. 
		   O recurso deve ser importado entre chaves {} e com nome exato. Ex: export funcaoUtilitaria;

export default 	 -> define um recurso como a exportação padrão de um arquivo. 
		  O recurso pode ser importado com qualquer nome e sem chaves. Ex: export default Componente;

import...from... -> importa um recurso no arquivo de trabalho. Ex: import {funcaoUtilitaria} from "./utilitarios";
							       Ex: import MeuComponente from "./componentes/Componente";

Estilização de componentes

estilo inline -> os estilos são passados por um objeto literal com dados chave-valor na propriedade style do componente. 
As propriedades css seguem o formato camelCase e os valores de propriedade são strings.
Ex:
	const estiloC2 = {textAlign: "center", backgroundColor: "#f00"};

	<Componente1 style= {{textAlign: "center", backgroundColor: "#fff"}}/>
	<Componente2 style= {estiloC2}/>

estilo externo -> os estilos são passados por um arquivo de folha de estilo importado no script. Ao importar, é
possível acessar as classes pelo atributo className do componente ou tag HTML.
Ex:
	import moduloCss from "./estilos/estilo1.css";  // importa o css como um módulo
	import "./estilos/estilo2.css";		     	// importa o css globalmente
	
	<Componente1 className= {"classe1"}/> ou <Componente1 className= {moduloCss.classe1}/>
	<Componente2 className= {"classe1 classe2"}/> //o espaço adiciona mais de uma classe ao componente.

OBS: Só é possível usar a síntaxe moduloCss.classe1 se a folha de estilo for importada como um módulo dentro do script.
Se for adicionada globalmente, as classes são acessadas só por uma string com o nome da classe.


Hooks

OBS: Os hooks não podem ser chamados dentro de funções ou outras estruturas, sempre no escopo global do componente.
O react diz que os rooks devem ser chamados sempre no mesmo número de vezes.

OBS: O react atualiza estado e referência de forma assincrona.

useState(estadoIncial) -> define um state (estado) para o componente para controlar os elementos internos.
			  Retorna o estado e uma função para atualizar ele: setState(novoState) ou setState(stateAnterior => ...)
			  O componente é re-renderizado sempre que o state muda.

Ex:
	import {useState} from 'react';
	
	export default function Componente(){
		const [state, setState] = useState(0); // estado com valor incial 0
		setState(state + 1) // atualiza o valor do state e re-renderiza o componente
	}

OBS: O state é uma constante e seu valor só pode ser atualizado pela função setState. 

Elevação de state (state lifting) -> no React, é um forma de compartilhar estados entre componentes para aumentar a 
reatividade da aplicação sem precisar declarar estados individuais para cada componente.

Um componente pai declara o state e o setState que são passados para os filhos através de suas props.
 
Quando um filho preicisar atualizar o state, ele chama a função setState que recebeu do pai
e todos os outros componentes que dependem do state serão atualizados imediatamente. 

	
useRef(referenciaInicial) -> cria um referência global para o componente semelhante ao state, mas sem atualizar o componente
			     ao atualizar a referência. Retorna a um objeto referência cujo valor é acessador pela propriedade current.

Ex:	import {useRef} from 'react';
	
	export default function Componente(){
		const ref = useRef(1);
		ref.current = ref.current + 1 //atualiza o valor da referência sem re-renderizar o componente.
	}


useEffect(callback, listaDependencias) -> executa um efeito colateral (operação) quando alguma dependência da lista for atualizada. 
			                Se a lista não for passada, o efeito será executado quando for o componente for renderizado e 
					quando qualquer estado do componente for atualizado.

useEffect(() => ...)                       -> executa o efeito toda a vez que o componente é renderizado.
useEffect(() => ..., []) 		   -> executa o efeito na primeira vez que o componente é renderizado.
useEffect(()=> ..., [dep1, dep2, ...]) 	   -> executa o efeito quando qualquer dependência da lista for atualizada. 
					      A dependência pode ser uma variável ou estado.

Ex: 
	import {useEffect, useState} from 'react';
	
	export default function ComponenteContador(){

		const [contador, setContador] = useState(0);
		const [finalizado, setFinalizado] = useState(false);
		
		setContador(contador + 1);

		useEffect(()=> console.log("Componente atualizado!")); // executado quando o componente for renderizado e quando qualquer state for atualizado
		useEffect(()=> console.log("Contador atualizado!" + contador), [contador]); // executado quando o contador for atualizado.
		
	}

